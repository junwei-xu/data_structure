## [TCP三次握手 四次挥手](https://blog.csdn.net/qq_38950316/article/details/81087809)

* 为什么连接的时候是三次握手，关闭的时候却是四次握手？  
  因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。  
  其中ACK报文是用来应答的，SYN报文是用来同步的。（`让我知道你已经知道了`）  
  但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。  
  只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。
* 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？  
  网络是不可靠的，有可能最后一个ACK丢失。  
  所以TIME_WAIT状态就是`用来重发可能丢失的ACK报文`。  
  在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。  
  Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。  
  所谓的2MSL是两倍的MSL(Maximum Segment Lifetime),MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。  
  如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。

## [TCP和UDP的区别](https://blog.csdn.net/Li_Ning_/article/details/52117463)

* `TCP面向连接`（如打电话要先拨号建立连接）;`UDP是无连接的`，即发送数据之前不需要建立连接
* `TCP提供可靠的服务`。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付
* `TCP面向字节流`，实际上是TCP把数据看成一连串无结构的字节流;`UDP是面向报文的`
* `UDP没有拥塞控制`，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）
* 每一条`TCP连接只能是点到点的`;UDP支持一对一，一对多，多对一和多对多的交互通信
* TCP首部开销20字节;UDP的首部开销小，只有8个字节
* `TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道`

## 多进程和多线程

* [理解](http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html)  
  类比车间和工人：进程相当于工厂的车间，线程相当于车间的工人
* 区别
    * 根本区别：进程是`操作系统资源分配`的基本单位，而线程是`处理器任务调度和执行`的基本单位
    * 资源开销：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），`线程之间切换的开销小`。
    * 包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；`线程是进程的一部分`，所以线程也被称为轻权进程或者轻量级进程。
    * 内存分配：`同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的`
    * 影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以`多进程要比多线程健壮`。
    * 执行过程：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是`线程不能独立执行`，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行
* 线程同步
* 多线程实际运用   
  Appium多设备测试

## [从URL输入到页面展现的过程](https://blog.fundebug.com/2019/02/28/what-happens-from-url-to-webpage/)

* DNS 解析:将域名解析成 IP 地址
* TCP 连接：TCP 三次握手
* 发送 HTTP 请求
* 服务器处理请求并返回 HTTP 报文
* 浏览器解析渲染页面
* 断开连接：TCP 四次挥手

## [HTTP和HTTPS](https://blog.csdn.net/xiaoming100001/article/details/81109617)

* HTTP特点
    * `无状态`：协议对客户端没有状态存储，对事物处理没有“记忆”能力，比如访问一个网站需要反复进行登录操作  
      -> `cookie和session or HTTP/1.1持久连接（HTTP keep-alive）方法`
      -> [长连接和短连接](https://www.cnblogs.com/0201zcr/p/4694945.html)
    * `无连接`：每次请求需要通过TCP三次握手四次挥手，和服务器重新建立连接。比如某个客户机在短时间多次请求同一个资源，服务器并不能区别是否已经响应过用户的请求，所以每次需要重新响应请求，需要耗费不必要的时间和流量。
    * `基于请求和响应`：基本的特性，由客户端发起请求，服务端响应
    * `简单快速、灵活`
    * `通信使用明文`、请求和响应不会对通信方进行确认、无法保护数据的完整性
* HTTPS(HTTP + SSL -> Secure Socket Layer)

## [cookie和session的区别](https://blog.csdn.net/chen13333336677/article/details/100939030)

* cookie数据存放在客户的`浏览器`上，session数据放在`服务器`上
* cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,如果主要`考虑到安全应当使用session`
* session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，如果主要考虑到减轻服务器性能方面，应当使用COOKIE
* 单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能3K。
* 所以：将登陆信息等重要信息存放为SESSION;其他信息如果需要保留，可以放在COOKIE中

## [get和post的区别](https://blog.fundebug.com/2019/02/22/compare-http-method-get-and-post/)

* 请求参数：GET请求参数是通过URL传递的，多个参数以&连接，POST请求放在request body中。   
  `解析报文是通过获取TCP数据，用正则等提取参数,所以也可以自己约定参数的写法`
* 请求缓存：GET请求会被缓存，而POST请求不会，除非手动设置。
* 收藏为书签：GET请求支持，POST请求不支持。
* 安全性：POST比GET安全，GET请求在浏览器回退时是无害的，而POST会再次请求。  
  `但只是相对安全，HTTP是明文传输的`
* 历史记录：GET请求参数会被完整保留在浏览历史记录里，而POST中的参数不会被保留。
* 编码方式：GET请求只能进行url编码，而POST支持多种编码方式。
* 对参数的数据类型：GET只接受ASCII字符，而POST没有限制。

## [网页加载速度慢的原因](https://blog.51cto.com/u_14232658/2486457)

* 本机问题：硬件、CPU、内存
* 网络问题：带宽、DNS解析
* 前端：JS阻塞、资源请求过多/大/时间过长
* 后端：代码冗余、数据库死锁/索引、动态请求时间过长

## [Python浅拷贝、深拷贝、直接赋值](https://www.runoob.com/w3cnote/python-understanding-dict-copy-shallow-or-deep.html)

* 直接赋值：其实就是对象的引用（别名）
* 浅拷贝(copy)：拷贝父对象，不会拷贝对象的内部的子对象
* 深拷贝(deepcopy)： copy 模块的 deepcopy 方法，完全拷贝了父对象及其子对象

## [Python垃圾回收机制](https://testerhome.com/topics/16556)

`引用计数机制`

* 导致引用计数 +1 的情况
    * 对象被创建，例如 a=23
    * 对象被引用，例如 b=a
    * 对象被作为参数，传入到一个函数中，例如func(a)
    * 对象作为一个元素，存储在容器中，例如list1=[a,a]
* 导致引用计数-1 的情况
    * 对象的别名被显式销毁，例如del a
    * 对象的别名被赋予新的对象，例如a=24
    * 一个对象离开它的作用域，例如 f 函数执行完毕时，func函数中的局部变量（全局变量不会）
    * 对象所在的容器被销毁，或从容器中删除对象

## Linux命令

* 查看进程  
  `ps -aux | grep java` -aux显示所有状态 grep过滤
* 终止进程  
  `kill -9 [PID]` -9表示强迫进程立即停止
* 查看端口号  
  `netstat -tunlp | grep 端口号`
* grep和find的区别  
  * find 查找文件或目录  `find 查找位置 文件名或目录名`
  * grep 在文件中查找字符串 `grep 字符串 文件名`
## [软件测试理论](https://blog.csdn.net/zhangkaiyazky/article/details/102525628)

* 测试用例设计方法   
  等价类划分、边界值、因果图划分、正交、场景、随机、错误推断
* 微信朋友圈测试用例（其他同理）
    * 功能：发送、浏览
    * 界面/易用性
    * 性能：服务器、客户端、压力
    * 安全
    * 兼容性
    * 网络测试：不同的网络、无网、弱网
    * 中断测试：数据交换、热启动、前后台、网络切换、App切换、断电、故障、来电等
  